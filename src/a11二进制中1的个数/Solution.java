package a11二进制中1的个数;
/*
 * 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
 * 
 * 思路：这里想复杂了：原来从整数转化成二进制的计算去考虑了，但其实不是；
 * 因为不管是整数还是负数，在计算机中负数已经用补码表示了，所以只需要判断正负就好了；
 * 
 * 
一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1
，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。
这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变
成0。如1100&1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成
0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。

扩展：1：一条语句判断一个整数是不是2的整数次方：（若是，则二进制中只有一个1，if(n&(n-1)==0)）
	2:两个整数m和n，计算需要改变m二进制中的多少位才能得到n：
		（1）：m^n:异或，不同为1，其中为1的位置即是需要改变的位置；
		（2）：while(n!=0){count++;n=n&(n-1)}统计个数；

 * */
public class Solution {
	public static void main(String[]args){
		System.out.println(NumberOf1(19930504));
	}
	static public int NumberOf1(int n) {
		/*
		int count=0;
		int	fude=0;
		if(n<0) {
			fude++;n=-n;'
		}
		while(n!=0){
			if((n&1)==1)
				count++;
			n=n>>1;
		}		
		return count+fude;
		*/
		int count=0;
		while(n!=0){
			count++;
			n=n&(n-1);
		}
		return count;
    }
}
